# -*- coding: utf-8 -*-
"""AI and ML project PART I.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C6ra9rUvplz6HEazq6pk0mV0FRCYHvxZ
"""

from queue import PriorityQueue, Queue, LifoQueue
import time

# Maze Definition (0 = path, 1 = wall)
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [0, 1, 0, 0, 0],
    [0, 0, 0, 1, 0]
]

start = (0, 0)
goal = (4, 4)
moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # Down, Up, Right, Left


# ---------- Helper Functions ----------

def is_valid(maze, pos):
    """Check if position is within bounds and not a wall"""
    x, y = pos
    return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 0


def reconstruct_path(came_from, current):
    """Reconstruct path from start to goal"""
    path = []
    while current:
        path.append(current)
        current = came_from.get(current)
    path.reverse()
    return path


def path_length(path):
    """Return path length (number of moves)"""
    return len(path) - 1 if path else float('inf')


# ---------- BFS Algorithm ----------

def bfs(maze, start, goal):
    queue = Queue()
    queue.put(start)
    came_from = {start: None}
    visited = set([start])

    while not queue.empty():
        current = queue.get()
        if current == goal:
            return reconstruct_path(came_from, goal)

        for move in moves:
            neighbor = (current[0] + move[0], current[1] + move[1])
            if is_valid(maze, neighbor) and neighbor not in visited:
                visited.add(neighbor)
                came_from[neighbor] = current
                queue.put(neighbor)
    return None


# ---------- DFS Algorithm ----------

def dfs(maze, start, goal):
    stack = LifoQueue()
    stack.put(start)
    came_from = {start: None}
    visited = set([start])

    while not stack.empty():
        current = stack.get()
        if current == goal:
            return reconstruct_path(came_from, goal)

        for move in moves:
            neighbor = (current[0] + move[0], current[1] + move[1])
            if is_valid(maze, neighbor) and neighbor not in visited:
                visited.add(neighbor)
                came_from[neighbor] = current
                stack.put(neighbor)
    return None


# ---------- A* Algorithm ----------

def heuristic(a, b):
    """Heuristic function for A* (Manhattan Distance)"""
    return abs(a[0] - b[0]) + abs(a[1] - b[1])


def astar(maze, start, goal):
    pq = PriorityQueue()
    pq.put((0, start))
    came_from = {start: None}
    cost = {start: 0}

    while not pq.empty():
        _, current = pq.get()
        if current == goal:
            return reconstruct_path(came_from, goal)

        for move in moves:
            next_node = (current[0] + move[0], current[1] + move[1])
            if is_valid(maze, next_node):
                new_cost = cost[current] + 1
                if next_node not in cost or new_cost < cost[next_node]:
                    cost[next_node] = new_cost
                    priority = new_cost + heuristic(goal, next_node)
                    pq.put((priority, next_node))
                    came_from[next_node] = current
    return None


# ---------- Run Algorithms with Timer ----------

print("Maze (0 = path, 1 = wall):")
for row in maze:
    print(row)

print("\nStart:", start, "Goal:", goal)

# --- BFS ---
start_time = time.time()
bfs_path = bfs(maze, start, goal)
bfs_time = (time.time() - start_time) * 1000  # in milliseconds

# --- DFS ---
start_time = time.time()
dfs_path = dfs(maze, start, goal)
dfs_time = (time.time() - start_time) * 1000

# --- A* ---
start_time = time.time()
astar_path = astar(maze, start, goal)
astar_time = (time.time() - start_time) * 1000

# ---------- Display Results ----------
print("\n--- PATH RESULTS ---")
print("BFS Path:", bfs_path)
print("DFS Path:", dfs_path)
print("A*  Path:", astar_path)

print("\n--- PATH LENGTH COMPARISON ---")
print(f"BFS Path Length: {path_length(bfs_path)}")
print(f"DFS Path Length: {path_length(dfs_path)}")
print(f"A*  Path Length: {path_length(astar_path)}")

print("\n--- EXECUTION TIME (ms) ---")
print(f"BFS Time: {bfs_time:.5f} ms")
print(f"DFS Time: {dfs_time:.5f} ms")
print(f"A*  Time: {astar_time:.5f} ms")

# ---------- Final Comparison ----------
best_path = min([("BFS", path_length(bfs_path)),
                 ("DFS", path_length(dfs_path)),
                 ("A*", path_length(astar_path))], key=lambda x: x[1])

fastest_algo = min([("BFS", bfs_time), ("DFS", dfs_time), ("A*", astar_time)], key=lambda x: x[1])

print("\n--- SUMMARY ---")
print(f"Shortest Path Found By: {best_path[0]} (Length = {best_path[1]})")
print(f"Fastest Algorithm: {fastest_algo[0]} ({fastest_algo[1]:.5f} ms)")